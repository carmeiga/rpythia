dtilde=d[res$p>0.1]
#d=d/sum(d)
Wtilde=(diag(dtilde))
W=diag(d)
#alphatilde=coef(Ztilde,Ytilde,Wtilde,lambda,mutilde,3)
alphatilde=coef(Z,Y,W,lambda,mu,5)
prediction=numeric(n);
for(i in 1:n) {
prediction[i]=kernel_machine(Z,as.numeric(Z[i,]),as.numeric(alphatilde),5)
}
plot(Yorig~mu)
plot(Yorig,prediction)
Y[is.na(Y)]=0
mu=res$Ypred
lambda=0.001
d=as.numeric(M/p)
Ytilde=Y[res$p>0.1]
Ztilde=Z[res$p>0.1,]
mutilde=mu[res$p>0.1]
dtilde=d[res$p>0.1]
#d=d/sum(d)
Wtilde=(diag(dtilde))
W=diag(d)
#alphatilde=coef(Ztilde,Ytilde,Wtilde,lambda,mutilde,3)
alphatilde=coef(Z,Y,W,lambda,mu,5)
prediction=numeric(n);
for(i in 1:n) {
prediction[i]=kernel_machine(Z,as.numeric(Z[i,]),as.numeric(alphatilde),5)
}
plot(Yorig~mu)
plot(Yorig,prediction)
#d=d/sum(d)
Wtilde=(diag(dtilde))
W=diag(d)
#alphatilde=coef(Ztilde,Ytilde,Wtilde,lambda,mutilde,3)
alphatilde=coef(Z,Y,W,lambda,mu,10)
prediction=numeric(n);
for(i in 1:n) {
prediction[i]=kernel_machine(Z,as.numeric(Z[i,]),as.numeric(alphatilde),10)
}
plot(Yorig~mu)
plot(Yorig,prediction)
Y[is.na(Y)]=0
mu=res$Ypred
lambda=0.001
d=as.numeric(M/p)
Ytilde=Y[res$p>0.1]
Ztilde=Z[res$p>0.1,]
mutilde=mu[res$p>0.1]
dtilde=d[res$p>0.1]
#d=d/sum(d)
Wtilde=(diag(dtilde))
W=diag(d)
#alphatilde=coef(Ztilde,Ytilde,Wtilde,lambda,mutilde,3)
alphatilde=coef(Z,Y,W,lambda,mu,15)
prediction=numeric(n);
for(i in 1:n) {
prediction[i]=kernel_machine(Z,as.numeric(Z[i,]),as.numeric(alphatilde),15)
}
plot(Yorig~mu)
plot(Yorig,prediction)
M
plot(M~Z[,1])
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
Rcpp::sourceCpp('particarlos/pythia8303/r/proba.cpp')
install.packages(c('Rcpp','RInside'))
install.packages(c('C50','RSNNS','e1071','xgboost'))
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
library(rhdf5)
BiocManager::install()
library(rhdf5)
install.packages("rhdf5")
library(rhdf5)
separadores <- read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char="")
View(separadores)
read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char="")
separ=as.vector(read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char=""))
separ
separ=as.numeric(read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char=""))
separ=as.numeric(read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char=""))
separ=as.numeric(read.table("~/particarlos/pythia8303/r/separadores.dat", quote="\"", comment.char="")$V1)
install.packages("tensorflow")
View(separadores)
library(tensorflow)
install_tensorflow()
Y
yes
install.packages("tensorflow")
install.packages("tensorflow")
library(tensorflow)
install_tensorflow()
library(tensorflow)
tf$constant("Hellow Tensorflow")
library(tensorflow)
tf$constant("Hellow Tensorflow")
library(keras)
library(tensorflow)
library(keras)
remove.packages("tensorflow", lib="~/R/x86_64-pc-linux-gnu-library/4.0")
install.packages("tensorflow")
library(tensorflow)
tf$constant("Hellow Tensorflow")
install_keras()
install.packages("keras")
library(keras)
mnist <- dataset_mnist()
model <- keras_model_sequential() %>%
layer_flatten(input_shape = c(28, 28)) %>%
layer_dense(units = 128, activation = "relu") %>%
layer_dropout(0.2) %>%
layer_dense(10, activation = "softmax")
summary(model)
model %>%
compile(
loss = "sparse_categorical_crossentropy",
optimizer = "adam",
metrics = "accuracy"
)
model %>%
fit(
x = mnist$train$x, y = mnist$train$y,
epochs = 5,
validation_split = 0.3,
verbose = 2
)
View(separadores)
View(separadores)
mesmo_proceso<-function(pro,tot) {
setwd("~/particarlos/pythia8303/rpythia")
pat=paste("_",pro,".txt$",sep="")
list_of_files <- list.files(path = ".", recursive = TRUE,
pattern = pat,
full.names = FALSE)
separ=as.numeric(read.table(list_of_files[4], quote="\"", comment.char="")$V1)
n=length(separ)
ev=n/2-1
library(readr)
for(i in 1:ev) {
temp <- read_table2(list_of_files[3], col_names=FALSE,skip =(separ[2*i+1]+2),n_max=(separ[2*i+2]-separ[2*i+1]-5))
temp$ev=rep(i+tot*ev,nrow(temp))
if (i==1)
out=temp
else
out=rbind(out,temp)
}
nomes= c('no','id','name','status', 'mother1','mother2','daughter1','daughter2','colour1','colour2','p_x','p_y','p_z','e','m','ev')
colnames(out)=nomes
pt <- as.numeric(read_table2(list_of_files[2], col_names = FALSE)[1,])
out$pt=pt[-length(pt)]
x <- as.numeric(read_table2(list_of_files[6], col_names = FALSE)[1,])
out$x=x[-length(x)]
y <- as.numeric(read_table2(list_of_files[7], col_names = FALSE)[1,])
out$y=y[-length(y)]
z <- as.numeric(read_table2(list_of_files[8], col_names = FALSE)[1,])
out$z=z[-length(z)]
q <- as.numeric(read_table2(list_of_files[1], col_names = FALSE)[1,])
out$q=q[-length(q)]
spin <- as.numeric(read_table2(list_of_files[5], col_names = FALSE)[1,])
out$spin=spin[-length(spin)]
estables_n=c('e-','e+','mu+','mu-','K+','K-','pi+','pi-','p+','pbar-','n0','nbar0','gamma','K_L0')
# parenteses indican particulas intermediarias (desintegranse)
estables=subset(out, (name %in% estables_n))
final=cbind(estables,rep(pro,nrow(estables)))
names(final)[23] <- "proc"
final$b=as.numeric(final$name=='p+' | final$name=='pbar-' | final$name=='n0' | final$name=='nbar0')
final$le=as.numeric(final$name=='e+' | final$name=='e-')
final$lm=as.numeric(final$name=='mu+' | final$name=='mu-')
return(final)
}
setwd("~/particarlos/pythia8303/rpythia")
s=mesmo_proceso('s',0)
View(s)
h=mesmo_proceso('h',1)
w=mesmo_proceso('w',2)
t=mesmo_proceso('t',3)
View(h)
estables=rbind(s,h,w,t)
minkowskiFuncPtr <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (arma::accu(arma::square(A - B))-2*pow(A(0,0)-B(0,0),2));
}", depends = c("RcppArmadillo"))
library(RcppXPtrUtils)
library(parallelDist)
minkowskiFuncPtr <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (arma::accu(arma::square(A - B))-2*pow(A(0,0)-B(0,0),2));
}", depends = c("RcppArmadillo"))
estables=rbind(s,h,w,t)
normalizacions=aggregate(estables$e, list(estables$ev), sum)
estables$en=estables$e
nev=nrow(normalizacions)
for(i in 1:nev) {
estables$en[estables$ev==i]=estables$e[estables$ev==i]/normalizacions$x[i]
}
aggregate(estables$proc, list(estables$ev),max)
p=1
proba1=estables[estables$ev==p,c(22,14,(11:13))]
View(proba1)
View(estables)
proba1=estables[estables$ev==p,c(27,14,(11:13))]
View(proba1)
disc1=estables[estables$ev==p,c('q','spin','proc','b','le','lm')]
View(disc1)
View(disc1)
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (int*(A(0,0)==B(0,0))+pow(A(1,0)-B(1,0),2)+int*(A(2,0)==B(2,0))+int*(A(3,0)==B(3,0))+int*(A(4,0)==B(4,0));
}", depends = c("RcppArmadillo"))
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (int*(A(0,0)==B(0,0))+pow(A(1,0)-B(1,0),2)+int*(A(2,0)==B(2,0))+int*(A(3,0)==B(3,0))+int*(A(4,0)==B(4,0)));
}", depends = c("RcppArmadillo"))
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return ((A(0,0)==B(0,0))+pow(A(1,0)-B(1,0),2)+(A(2,0)==B(2,0))+(A(3,0)==B(3,0))+(A(4,0)==B(4,0)));
}", depends = c("RcppArmadillo"))
disc1[c(1,2),],
disc1[c(1,2),]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc1[c(1,2),]
disc1[c(3,70),]
disc1[c(3,110),]
isc1[c(3,111),]
disc1[c(3,111),]
res2=parDist(disc1[c(3,111),], method="custom", func = trivial_dist)
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
res2=parDist(as.matrix(t(disc1[c(3,111),])), method="custom", func = trivial_dist)
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return ((A(0,0)==B(0,0))+pow(A(0,1)-B(0,1),2)+(A(0,2)==B(0,2))+(A(0,3)==B(0,3))+(A(0,4)==B(0,4)));
}", depends = c("RcppArmadillo"))
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
as.matrix(res2)
disc1[c(3,111),])
disc1[c(3,111),]
disc1[c(3,111),]
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return ((A(0,0)!=B(0,0))+pow(A(0,1)-B(0,1),2)+(A(0,2)!=B(0,2))+(A(0,3)!=B(0,3))+(A(0,4)!=B(0,4)));
}", depends = c("RcppArmadillo"))
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
res2
proba1=estables[estables$ev==p,c(27,14,(11:13))]
View(proba1)
setwd("~/particarlos/pythia8303/rpythia")
source('ler.r')
s=mesmo_proceso('s',0)
h=mesmo_proceso('h',1)
w=mesmo_proceso('w',2)
t=mesmo_proceso('t',3)
library(transport)
library(RcppArmadillo)
## user-defined distance function
library(RcppArmadillo)
# Use RcppXPtrUtils for simple usage of C++ external pointers
library(RcppXPtrUtils)
library(parallelDist)
## user-defined distance function
minkowskiFuncPtr <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (arma::accu(arma::square(A - B))-2*pow(A(0,0)-B(0,0),2));
}", depends = c("RcppArmadillo"))
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return ((A(0,0)!=B(0,0))+pow(A(0,1)-B(0,1),2)+(A(0,2)!=B(0,2))+(A(0,3)!=B(0,3))+(A(0,4)!=B(0,4)));
}", depends = c("RcppArmadillo"))
estables=rbind(s,h,w,t)
normalizacions=aggregate(estables$e, list(estables$ev), sum)
estables$en=estables$e
nev=nrow(normalizacions)
for(i in 1:nev) {
estables$en[estables$ev==i]=estables$e[estables$ev==i]/normalizacions$x[i]
}
aggregate(estables$proc, list(estables$ev),max)
d=matrix(0,nrow=nev,ncol=nev)
for(k in 1:nev) {
for(p in 1:nev) {
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(22,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
as.matrix(res2)
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
# minkowski<-function(cuadri1,cuadri2) {
#   return(-cuadri1[1]*cuadri1[1]+sum(cuadri1[2:4]*cuadri1[2:4])-cuadri2[1]*cuadri2[1]+sum(cuadri2[2:4]*cuadri2[2:4])-2*(-cuadri1[1]*cuadri2[1]+sum(cuadri1[2:4]*cuadri2[2:4])))
# }
#
# for(i in 1:n) {
#   for(j in 1:m){
#
#     custos[i,j]=minkowski(as.numeric(proba1[i,]),as.numeric(proba2[j,]))
# }
# }
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
res=res1+res2 #distancia ao cadrado
# }
castres=as.matrix(res)
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
d[k,p]=sqrt(wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)) # 4-Wasserstein
}
}
write.table(d,file="distancias.dat",row.names=FALSE,col.names=FALSE)
d=matrix(0,nrow=nev,ncol=nev)
for(k in 1:nev) {
for(p in 1:nev) {
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(22,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
as.matrix(res2)
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
# minkowski<-function(cuadri1,cuadri2) {
#   return(-cuadri1[1]*cuadri1[1]+sum(cuadri1[2:4]*cuadri1[2:4])-cuadri2[1]*cuadri2[1]+sum(cuadri2[2:4]*cuadri2[2:4])-2*(-cuadri1[1]*cuadri2[1]+sum(cuadri1[2:4]*cuadri2[2:4])))
# }
#
# for(i in 1:n) {
#   for(j in 1:m){
#
#     custos[i,j]=minkowski(as.numeric(proba1[i,]),as.numeric(proba2[j,]))
# }
# }
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
castres=as.matrix(res1)+as.matrix(res2) #distancia ao cadrado
# }
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
d[k,p]=sqrt(wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)) # 4-Wasserstein
}
}
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(22,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
res2=parDist(as.matrix(disc1[c(3,111),]), method="custom", func = trivial_dist)
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
castres=as.matrix(res1)+as.matrix(res2) #distancia ao cadrado
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
View(custos)
res2
as.matrix(res2)
d=matrix(0,nrow=nev,ncol=nev)
for(k in 1:nev) {
for(p in 1:nev) {
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(22,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
# minkowski<-function(cuadri1,cuadri2) {
#   return(-cuadri1[1]*cuadri1[1]+sum(cuadri1[2:4]*cuadri1[2:4])-cuadri2[1]*cuadri2[1]+sum(cuadri2[2:4]*cuadri2[2:4])-2*(-cuadri1[1]*cuadri2[1]+sum(cuadri1[2:4]*cuadri2[2:4])))
# }
#
# for(i in 1:n) {
#   for(j in 1:m){
#
#     custos[i,j]=minkowski(as.numeric(proba1[i,]),as.numeric(proba2[j,]))
# }
# }
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
castres=as.matrix(res1)+as.matrix(res2) #distancia ao cadrado
# }
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
d[k,p]=sqrt(wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)) # 4-Wasserstein
}
}
wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
View(proba1)
wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)
proba2$en
proba1$en
proba2=estables[estables$ev==k,c(27,14,(11:13))]
View(proba2)
d=matrix(0,nrow=nev,ncol=nev)
for(k in 1:nev) {
for(p in 1:nev) {
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(27,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
# minkowski<-function(cuadri1,cuadri2) {
#   return(-cuadri1[1]*cuadri1[1]+sum(cuadri1[2:4]*cuadri1[2:4])-cuadri2[1]*cuadri2[1]+sum(cuadri2[2:4]*cuadri2[2:4])-2*(-cuadri1[1]*cuadri2[1]+sum(cuadri1[2:4]*cuadri2[2:4])))
# }
#
# for(i in 1:n) {
#   for(j in 1:m){
#
#     custos[i,j]=minkowski(as.numeric(proba1[i,]),as.numeric(proba2[j,]))
# }
# }
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
castres=as.matrix(res1)+as.matrix(res2) #distancia ao cadrado
# }
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
d[k,p]=sqrt(wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)) # 4-Wasserstein
}
}
View(d)
sim=as.matrix(distancias+t(distancias))/2
sim=as.matrix(d+t(d))/2
diag(sim)=0
perm=sample(seq(1:400), 400,replace = FALSE, prob = NULL)
shuffle=sim[perm,perm]
perm=sample(seq(1:nev), nev,replace = FALSE, prob = NULL)
shuffle=sim[perm,perm]
View(shuffle)
library(energy)
perm=sample(seq(1:nev), nev,replace = FALSE, prob = NULL)
shuffle=sim[perm,perm]
library(energy)
simp=as.dist(shuffle)
resp=kgroups(simp, 2, iter.max = 15, nstart = 1, cluster = NULL)
resp
resp=kgroups(simp, 4, iter.max = 15, nstart = 1, cluster = NULL)
resp
setwd("~/particarlos/pythia8303/rpythia")
source('ler.r')
s=mesmo_proceso('s',0)
h=mesmo_proceso('h',1)
w=mesmo_proceso('w',2)
t=mesmo_proceso('t',3)
library(transport)
## user-defined distance function
library(RcppArmadillo)
# Use RcppXPtrUtils for simple usage of C++ external pointers
library(RcppXPtrUtils)
library(parallelDist)
## user-defined distance function
minkowskiFuncPtr <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return (arma::accu(arma::square(A - B))-2*pow(A(0,0)-B(0,0),2));
}", depends = c("RcppArmadillo"))
trivial_dist  <- cppXPtr(
"double customDist(const arma::mat &A, const arma::mat &B) {
return ((A(0,0)!=B(0,0))+pow(A(0,1)-B(0,1),2)+(A(0,2)!=B(0,2))+(A(0,3)!=B(0,3))+(A(0,4)!=B(0,4)));
}", depends = c("RcppArmadillo"))
estables=rbind(s,h,w,t)
normalizacions=aggregate(estables$e, list(estables$ev), sum)
estables$en=estables$e
nev=nrow(normalizacions)
for(i in 1:nev) {
estables$en[estables$ev==i]=estables$e[estables$ev==i]/normalizacions$x[i]
}
aggregate(estables$proc, list(estables$ev),max)
d=matrix(0,nrow=nev,ncol=nev)
for(k in 1:nev) {
for(p in 1:nev) {
proba1=estables[estables$ev==p,c(27,14,(11:13))]
proba2=estables[estables$ev==k,c(27,14,(11:13))]
disc1=estables[estables$ev==p,c('q','spin','b','le','lm')]
disc2=estables[estables$ev==k,c('q','spin','b','le','lm')]
n=nrow(proba1)
m=nrow(proba2)
custos=matrix(0,nrow=nrow(proba1),ncol=nrow(proba2))
# minkowski<-function(cuadri1,cuadri2) {
#   return(-cuadri1[1]*cuadri1[1]+sum(cuadri1[2:4]*cuadri1[2:4])-cuadri2[1]*cuadri2[1]+sum(cuadri2[2:4]*cuadri2[2:4])-2*(-cuadri1[1]*cuadri2[1]+sum(cuadri1[2:4]*cuadri2[2:4])))
# }
#
# for(i in 1:n) {
#   for(j in 1:m){
#
#     custos[i,j]=minkowski(as.numeric(proba1[i,]),as.numeric(proba2[j,]))
# }
# }
res1=parDist(as.matrix(rbind(proba1[,-1],proba2[,-1])), method="custom", func = minkowskiFuncPtr)
res2=parDist(as.matrix(rbind(disc1,disc2)), method="custom", func = trivial_dist)
castres=as.matrix(res1)+as.matrix(res2) #distancia ao cadrado
# }
custos=t(castres[-seq(1,n),-seq(n+1,m+n)])
d[k,p]=sqrt(wasserstein(proba1$en, proba2$en, p=2, tplan=NULL, costm=abs(custos),prob=TRUE)) # 4-Wasserstein
}
}
View(d)
View(d)
write.table(d,file="distancias.dat",row.names=FALSE,col.names=FALSE)
sim=as.matrix(d+t(d))/2
diag(sim)=0
perm=sample(seq(1:nev), nev,replace = FALSE, prob = NULL)
shuffle=sim[perm,perm]
library(energy)
simp=as.dist(shuffle)
resp=kgroups(simp, 4, iter.max = 15, nstart = 1, cluster = NULL)
resp
resp$cluster[order(perm)]
